--- START OF FILE index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PDFX: AI Document Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      /* For a better dark mode experience */
      body {
        background-color: #111827; /* gray-900 */
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://aistudiocdn.com/react@^19.1.1",
    "@google/genai": "https://aistudiocdn.com/@google/genai@^1.18.0",
    "react/": "https://aistudiocdn.com/react@^19.1.1/",
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.1.1/"
  }
}
</script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://unpkg.com/downloadjs@1.4.7/download.js"></script>
</head>
  <body>
    <div id="root"></div>
    <script type="module" src="/index.tsx"></script>
  </body>
</html>
--- END OF FILE index.html ---
--- START OF FILE index.tsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import App from './App';

const rootElement = document.getElementById('root');
if (!rootElement) {
  throw new Error("Could not find root element to mount to");
}

const root = ReactDOM.createRoot(rootElement);
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);
--- END OF FILE index.tsx ---
--- START OF FILE metadata.json ---
{
  "name": "PDFX AI Document Engine ",
  "description": "An AI-powered, JavaScript-executing, payment-handling PDF system frontend. This application provides a dashboard to edit documents, run scripts, trigger AI actions, and configure monetization.",
  "requestFramePermissions": []
}
--- END OF FILE metadata.json ---
--- START OF FILE App.tsx ---
import React, { useState, useCallback, useEffect } from 'react';
import Header from './components/Header';
import Sidebar from './components/Sidebar';
import Workspace from './components/Workspace';
import Terminal from './components/Terminal';
import { Script, PaymentOption, MonetizationType } from './types';
import { generateContent } from './services/geminiService';
import { debugScriptWithMockAI } from './services/mockAiService';
import { runScriptInMockSandbox } from './mocks/SandboxRunner';
import { MockPayment, PaymentSession } from './mocks/MockPayment';
import { MockChain, ChainEvent } from './mocks/MockChain';

// Declare global variables from CDN scripts for TypeScript
declare var pdfLib: any;
declare var download: any;

const App: React.FC = () => {
  const [selectedPdf, setSelectedPdf] = useState<File | null>(null);
  const [documentContent, setDocumentContent] = useState<string>('');
  const [scriptContent, setScriptContent] = useState<string>('');
  const [consoleOutput, setConsoleOutput] = useState<string[]>(['Welcome to the PDFX Mock AI Runtime.']);
  const [isLoading, setIsLoading] = useState<boolean>(false);

  const [paymentOptions, setPaymentOptions] = useState<PaymentOption[]>([
    { id: 'stripe', name: 'Stripe', enabled: true },
    { id: 'ethereum', name: 'Ethereum', enabled: false },
    { id: 'solana', name: 'Solana', enabled: false },
    { id: 'paypal', name: 'PayPal', enabled: true },
  ]);

  const [monetization, setMonetization] = useState({
    type: MonetizationType.PAY_PER_VIEW,
    price: 5,
  });

  const [appliedEffects, setAppliedEffects] = useState<any[]>([]);
  const [chainEvents, setChainEvents] = useState<ChainEvent[]>([]);
  const [paymentSessions, setPaymentSessions] = useState<PaymentSession[]>([]);

  const refreshMockData = useCallback(() => {
    setChainEvents(MockChain.list());
    setPaymentSessions(MockPayment.list());
  }, []);

  useEffect(() => {
    refreshMockData();
  }, [refreshMockData]);


  const logToConsole = useCallback((message: string) => {
    setConsoleOutput(prev => [...prev, `> ${message}`]);
  }, []);

  const handleFileUpload = (file: File) => {
    setSelectedPdf(file);
    logToConsole(`PDF uploaded: ${file.name}`);
  };

  const handleScriptSelect = (script: Script) => {
    setScriptContent(script.code);
    logToConsole(`Loaded script: ${script.name}`);
  };
  
  const handleRunScript = useCallback(async () => {
    if (!scriptContent.trim()) {
      logToConsole('Error: Cannot run an empty script.');
      return;
    }
    setIsLoading(true);
    logToConsole(`Interpreting script with MockAI Runtime...\n---\n${scriptContent}\n---`);
    
    await runScriptInMockSandbox(scriptContent, {
      onLog: (msg) => logToConsole(msg),
      onWatermark: (page, text) => {
        const effect = { type: 'WATERMARK', page, text, id: Date.now() };
        setAppliedEffects(prev => [effect, ...prev]);
        logToConsole(`EFFECT APPLIED: Watermark on page ${page} with text "${text}"`);
      },
      onHighlight: (text) => {
        const effect = { type: 'HIGHLIGHT', text, id: Date.now() };
        setAppliedEffects(prev => [effect, ...prev]);
        logToConsole(`EFFECT APPLIED: Highlight text "${text}"`);
      },
      onLockPages: (pages, price) => {
         const effect = { type: 'LOCK_PAGES', pages, price, id: Date.now() };
         setAppliedEffects(prev => [effect, ...prev]);
         logToConsole(`EFFECT APPLIED: Locked pages [${pages.join(', ')}] for $${((price || 0)/100).toFixed(2)}`);
      },
      onMintNFT: (metadata) => {
        const effect = { type: 'MINT_NFT', metadata, id: Date.now() };
        setAppliedEffects(prev => [effect, ...prev]);
        logToConsole(`EFFECT APPLIED: Minted NFT with metadata: ${JSON.stringify(metadata)}`);
      }
    });

    refreshMockData();
    logToConsole('--- MockAI interpretation finished ---');
    setIsLoading(false);
  }, [scriptContent, logToConsole, refreshMockData]);

  const handleDebugWithAI = useCallback(async () => {
    if (!scriptContent.trim()) {
      logToConsole('Error: Cannot debug an empty script.');
      return;
    }
    setIsLoading(true);
    logToConsole('Asking MockAI for debugging help...');
    try {
      const simulatedError = "TypeError: Cannot read properties of null (reading 'data')";
      const aiResponse = await debugScriptWithMockAI(scriptContent, simulatedError);
      logToConsole(`MockAI Debugger:\n---\n${aiResponse}\n---`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      logToConsole(`Error debugging with MockAI: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  }, [scriptContent, logToConsole]);

  const handleGenerateContent = async () => {
    if (!documentContent.trim()) {
        logToConsole("Cannot generate from empty content. Write a prompt in the editor.");
        return;
    }
    setIsLoading(true);
    logToConsole("Generating content with AI...");
    try {
      const aiResponse = await generateContent(documentContent);
      setDocumentContent(prev => `${prev}\n\n${aiResponse}`);
      logToConsole("AI content generation successful.");
    } catch(error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      logToConsole(`Error generating content with AI: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleGeneratePdf = async () => {
    if (!documentContent.trim()) {
      logToConsole("Cannot generate PDF from empty content. Write something in the editor.");
      return;
    }
    setIsLoading(true);
    logToConsole("Generating PDF from editor content...");
    try {
      const { PDFDocument, rgb, StandardFonts } = pdfLib;
      
      const pdfDoc = await PDFDocument.create();
      const page = pdfDoc.addPage();
      const { width, height } = page.getSize();
      const font = await pdfDoc.embedFont(StandardFonts.Helvetica);
      const fontSize = 12;

      page.drawText(documentContent, {
        x: 50,
        y: height - 4 * fontSize,
        font,
        size: fontSize,
        color: rgb(0, 0, 0),
        maxWidth: width - 100,
        lineHeight: 15,
      });

      const pdfBytes = await pdfDoc.save();
      const pdfFile = new File([pdfBytes], "generated-document.pdf", { type: "application/pdf" });

      setSelectedPdf(pdfFile);
      logToConsole(`Generated "${pdfFile.name}" and loaded into viewer.`);
      
      download(pdfBytes, "generated-document.pdf", "application/pdf");
      logToConsole(`Triggered download for "${pdfFile.name}".`);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
      logToConsole(`Error generating PDF: ${errorMessage}`);
    } finally {
      setIsLoading(false);
    }
  };

  const handleConfirmPayment = (sessionId: string) => {
    logToConsole(`Attempting to confirm mock payment: ${sessionId}`);
    const confirmed = MockPayment.confirmSession(sessionId);
    if (confirmed) {
      logToConsole(`Payment ${sessionId} confirmed successfully!`);
      MockChain.push('payment_confirmed', { sessionId });
      refreshMockData();
    } else {
      logToConsole(`Failed to confirm payment ${sessionId}.`);
    }
  };


  return (
    <div className="bg-gray-900 text-gray-200 min-h-screen flex flex-col font-sans">
      <Header />
      <main className="flex-grow flex overflow-hidden">
        <Sidebar 
          onScriptSelect={handleScriptSelect}
          paymentOptions={paymentOptions}
          onPaymentOptionChange={(id) => {
            setPaymentOptions(prev => 
              prev.map(opt => opt.id === id ? { ...opt, enabled: !opt.enabled } : opt)
            );
          }}
          monetization={monetization}
          onMonetizationChange={setMonetization}
          paymentSessions={paymentSessions}
          chainEvents={chainEvents}
          onConfirmPayment={handleConfirmPayment}
        />
        <div className="flex-grow flex flex-col md:flex-row overflow-hidden">
          <Workspace
            selectedPdf={selectedPdf}
            onFileUpload={handleFileUpload}
            documentContent={documentContent}
            onDocumentChange={setDocumentContent}
            onGenerateContent={handleGenerateContent}
            onGeneratePdf={handleGeneratePdf}
            isLoading={isLoading}
            appliedEffects={appliedEffects}
          />
          <Terminal
            scriptContent={scriptContent}
            onScriptChange={setScriptContent}
            consoleOutput={consoleOutput}
            onRun={handleRunScript}
            onDebug={handleDebugWithAI}
            onClear={() => setConsoleOutput(['Console cleared.'])}
            isLoading={isLoading}
          />
        </div>
      </main>
    </div>
  );
};

export default App;
--- END OF FILE App.tsx ---
--- START OF FILE types.ts ---
export interface Script {
  id: string;
  name: string;
  description: string;
  code: string;
}

export interface PaymentOption {
  id: string;
  name: string;
  enabled: boolean;
}

export enum MonetizationType {
    PAY_PER_VIEW = 'Pay-per-view',
    PER_PAGE = 'Per-page unlock',
    FULL_DOCUMENT = 'Full document unlock',
}

export interface Monetization {
    type: MonetizationType;
    price: number;
}
--- END OF FILE types.ts ---
--- START OF FILE services/geminiService.ts ---
import { GoogleGenAI } from "@google/genai";

const API_KEY = process.env.API_KEY;

if (!API_KEY) {
  throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: API_KEY });
const model = "gemini-2.5-flash";

export const generateContent = async (prompt: string): Promise<string> => {
  try {
    const response = await ai.models.generateContent({
      model,
      contents: prompt,
      config: {
        systemInstruction: "You are an AI assistant for a document editor. Your task is to expand upon the user's text. Be creative and helpful. Generate content in markdown format.",
        temperature: 0.7,
        topP: 0.95,
      },
    });
    return response.text;
  } catch (error) {
    console.error("Gemini API error in generateContent:", error);
    throw new Error("Failed to generate content from Gemini API.");
  }
};


export const debugScriptWithAI = async (script: string, error: string): Promise<string> => {
  const prompt = `
    You are an expert JavaScript debugger. A user's script has failed.
    Analyze the provided JavaScript code and the error message, then provide a corrected version of the script.
    Explain the error and the fix clearly and concisely.
    Format your response in markdown.

    --- SCRIPT ---
    ${script}
    --- END SCRIPT ---

    --- ERROR MESSAGE ---
    ${error}
    --- END ERROR MESSAGE ---
  `;

  try {
    const response = await ai.models.generateContent({
      model,
      contents: prompt,
    });
    return response.text;
  } catch (error) {
    console.error("Gemini API error in debugScriptWithAI:", error);
    throw new Error("Failed to debug script with Gemini API.");
  }
};
--- END OF FILE services/geminiService.ts ---
--- START OF FILE services/mockAiService.ts ---
import { MockAI } from '../mocks/MockAI';

export const debugScriptWithMockAI = async (script: string, error: string): Promise<string> => {
    const { suggestion, explanation } = MockAI.debugScript(script, error);
    return `### Mock AI Debugger Analysis
**Explanation:** ${explanation}

---

### Suggested Code
\`\`\`javascript
${suggestion}
\`\`\`
    `;
}
--- END OF FILE services/mockAiService.ts ---
--- START OF FILE components/Header.tsx ---
import React from 'react';

const Header: React.FC = () => {
  return (
    <header className="bg-gray-900 border-b border-gray-700 p-4 flex justify-between items-center z-10 shadow-md">
      <div className="flex items-center space-x-3">
        <div className="w-8 h-8 bg-indigo-600 rounded-md flex items-center justify-center font-bold text-white">P</div>
        <h1 className="text-xl font-bold text-white tracking-wider">PDFX</h1>
        <span className="text-xs bg-indigo-500 text-white px-2 py-1 rounded-full">Godmode</span>
      </div>
      <div className="flex items-center space-x-4">
         <span className="text-sm text-gray-400">James</span>
         <img src="https://picsum.photos/40/40" alt="User Avatar" className="w-8 h-8 rounded-full border-2 border-gray-600"/>
      </div>
    </header>
  );
};

export default Header;
--- END OF FILE components/Header.tsx ---
--- START OF FILE components/Sidebar.tsx ---
import React from 'react';
import { Script, PaymentOption, Monetization, MonetizationType } from '../types';
import ScriptIcon from './icons/ScriptIcon';
import PaymentIcon from './icons/PaymentIcon';
import BlockchainIcon from './icons/BlockchainIcon';
import ServerIcon from './icons/ServerIcon';
import { PaymentSession } from '../mocks/MockPayment';
import { ChainEvent } from '../mocks/MockChain';


const SCRIPTS: Script[] = [
  { id: 'watermark', name: 'Auto Watermarking', description: 'Dynamically add watermarks to the document.', code: `// Auto Watermark Script
// Try changing the page number or the text!
// Example: watermark page 2 text "DRAFT"
applyWatermark(pdfDoc, 'CONFIDENTIAL');` },
  { id: 'pay-to-view', name: 'View-to-Pay Trigger', description: 'Require payment after a certain number of views.', code: `// View-to-Pay Trigger Script
// This script simulates locking pages and creating a payment session.
// Try changing the price! e.g., "unlock for $10"
unlock pages for $5;` },
  { id: 'time-unlock', name: 'Time-Based Unlocking', description: 'Unlock pages after a specific time.', code: `// Time-Based Page Unlocking Script
// This is a placeholder for a future feature.
// The MockAI doesn't have a heuristic for this yet.
// See what it does as a fallback!
unlock page 5 at timestamp 1672531200;` },
  { id: 'ai-qa', name: 'AI Q&A on Content', description: 'Enable AI to answer questions about the doc.', code: `// AI Q&A Script
// This script simulates minting an NFT of the document.
// The AI interprets "mint" and logs it to the mock chain.
mint nft of this document version;` },
];

interface SidebarProps {
  onScriptSelect: (script: Script) => void;
  paymentOptions: PaymentOption[];
  onPaymentOptionChange: (id: string) => void;
  monetization: Monetization;
  onMonetizationChange: (monetization: Monetization) => void;
  paymentSessions: PaymentSession[];
  chainEvents: ChainEvent[];
  onConfirmPayment: (sessionId: string) => void;
}

const Sidebar: React.FC<SidebarProps> = ({ onScriptSelect, paymentOptions, onPaymentOptionChange, monetization, onMonetizationChange, paymentSessions, chainEvents, onConfirmPayment }) => {
  return (
    <aside className="w-80 bg-gray-900 border-r border-gray-800 p-4 flex-shrink-0 flex flex-col space-y-8 overflow-y-auto">
      {/* Script Library */}
      <div>
        <h2 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3 flex items-center"><ScriptIcon className="w-4 h-4 mr-2" /> Script Library</h2>
        <div className="space-y-2">
          {SCRIPTS.map(script => (
            <button key={script.id} onClick={() => onScriptSelect(script)} className="w-full text-left p-2 rounded-md bg-gray-800 hover:bg-indigo-600 transition-colors duration-200">
              <p className="font-semibold text-sm">{script.name}</p>
              <p className="text-xs text-gray-400">{script.description}</p>
            </button>
          ))}
        </div>
      </div>

      {/* Payment Layer */}
      <div>
        <h2 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3 flex items-center"><PaymentIcon className="w-4 h-4 mr-2" /> Embedded Payments</h2>
        <div className="space-y-3">
          {paymentOptions.map(option => (
             <label key={option.id} className="flex items-center justify-between p-2 bg-gray-800 rounded-md cursor-pointer">
              <span className="text-sm font-medium">{option.name}</span>
              <div className="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                <input type="checkbox" checked={option.enabled} onChange={() => onPaymentOptionChange(option.id)} className="toggle-checkbox absolute block w-6 h-6 rounded-full bg-white border-4 appearance-none cursor-pointer"/>
                <span className="toggle-label block overflow-hidden h-6 rounded-full bg-gray-600 cursor-pointer"></span>
              </div>
            </label>
          ))}
        </div>
      </div>
      
      {/* Monetization */}
      <div>
         <h2 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3 flex items-center"><BlockchainIcon className="w-4 h-4 mr-2" /> Monetization</h2>
         <div className="space-y-3 p-3 bg-gray-800 rounded-md">
            <div>
              <label htmlFor="monetization-type" className="block text-xs font-medium text-gray-400 mb-1">Pricing Model</label>
              <select 
                id="monetization-type"
                value={monetization.type}
                onChange={(e) => onMonetizationChange({...monetization, type: e.target.value as MonetizationType})}
                className="w-full p-2 bg-gray-700 border border-gray-600 rounded-md text-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none"
              >
                {Object.values(MonetizationType).map(type => (
                  <option key={type} value={type}>{type}</option>
                ))}
              </select>
            </div>
            <div>
              <label htmlFor="monetization-price" className="block text-xs font-medium text-gray-400 mb-1">Price (USD)</label>
               <div className="relative">
                <span className="absolute inset-y-0 left-0 flex items-center pl-3 text-gray-400">$</span>
                <input 
                  type="number"
                  id="monetization-price"
                  value={monetization.price}
                  onChange={(e) => onMonetizationChange({...monetization, price: parseFloat(e.target.value) || 0})}
                  className="w-full p-2 pl-7 bg-gray-700 border border-gray-600 rounded-md text-sm focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none"
                />
              </div>
            </div>
         </div>
         <p className="text-xs text-gray-500 mt-2">Blockchain logging is enabled by default.</p>
      </div>

       {/* Mock Payments Log */}
      <div>
        <h2 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3 flex items-center"><PaymentIcon className="w-4 h-4 mr-2" /> Mock Payments Log</h2>
        <div className="space-y-2 max-h-48 overflow-y-auto p-2 bg-gray-800 rounded-md border border-gray-700">
          {paymentSessions.length > 0 ? paymentSessions.map(session => (
            <div key={session.id} className="text-xs p-2 bg-gray-700 rounded">
              <p className="font-bold text-gray-300 truncate">ID: {session.id}</p>
              <p>Amount: ${(session.amountCents / 100).toFixed(2)}</p>
              <p>Status: <span className={`font-semibold ${session.status === 'paid' ? 'text-green-400' : 'text-yellow-400'}`}>{session.status}</span></p>
              {session.status === 'pending' && (
                <button 
                  onClick={() => onConfirmPayment(session.id)}
                  className="w-full mt-2 text-center bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-1 px-2 rounded-md text-xs transition-colors duration-200">
                  Confirm Payment
                </button>
              )}
            </div>
          )) : <p className="text-xs text-gray-500 text-center p-2">No payment sessions yet.</p>}
        </div>
      </div>

      {/* Mock Chain Log */}
      <div>
        <h2 className="text-xs font-semibold text-gray-400 uppercase tracking-wider mb-3 flex items-center"><ServerIcon className="w-4 h-4 mr-2" /> Mock Chain Log</h2>
        <div className="space-y-2 max-h-48 overflow-y-auto p-2 bg-gray-800 rounded-md border border-gray-700">
           {chainEvents.length > 0 ? chainEvents.map(event => (
            <div key={event.id} className="text-xs p-2 bg-gray-700 rounded font-mono">
              <p className="text-indigo-400 font-bold">{event.type}</p>
              <p className="text-gray-400">{new Date(event.timestamp).toLocaleTimeString()}</p>
              <p className="text-gray-500 text-[10px] break-words">{JSON.stringify(event.payload)}</p>
            </div>
          )) : <p className="text-xs text-gray-500 text-center p-2">No chain events recorded.</p>}
        </div>
      </div>


      <style>{`
        .toggle-checkbox:checked { right: 0; border-color: #4f46e5; }
        .toggle-checkbox:checked + .toggle-label { background-color: #4f46e5; }
      `}</style>
    </aside>
  );
};

export default Sidebar;
--- END OF FILE components/Sidebar.tsx ---
--- START OF FILE components/Workspace.tsx ---
import React, { useState, useRef } from 'react';
import DocumentIcon from './icons/DocumentIcon';
import AIIcon from './icons/AIIcon';

interface WorkspaceProps {
  selectedPdf: File | null;
  onFileUpload: (file: File) => void;
  documentContent: string;
  onDocumentChange: (content: string) => void;
  onGenerateContent: () => void;
  onGeneratePdf: () => void;
  isLoading: boolean;
  appliedEffects: any[];
}

const Workspace: React.FC<WorkspaceProps> = ({ selectedPdf, onFileUpload, documentContent, onDocumentChange, onGenerateContent, onGeneratePdf, isLoading, appliedEffects }) => {
  const [activeTab, setActiveTab] = useState<'editor' | 'pdf'>('editor');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    if (event.target.files && event.target.files[0]) {
      onFileUpload(event.target.files[0]);
      setActiveTab('pdf');
    }
  };
  
  const handleUploadClick = () => {
    fileInputRef.current?.click();
  };

  return (
    <div className="flex-1 flex flex-col bg-gray-800 m-2 rounded-lg overflow-hidden border border-gray-700">
      <div className="flex-shrink-0 bg-gray-900 flex items-center border-b border-gray-700">
        <button 
          onClick={() => setActiveTab('editor')}
          className={`px-4 py-2 text-sm font-medium ${activeTab === 'editor' ? 'text-white bg-gray-700' : 'text-gray-400 hover:bg-gray-800'}`}
        >
          Editor / Notepad
        </button>
        <button 
          onClick={() => setActiveTab('pdf')}
          className={`px-4 py-2 text-sm font-medium ${activeTab === 'pdf' ? 'text-white bg-gray-700' : 'text-gray-400 hover:bg-gray-800'}`}
        >
          PDF View
        </button>
      </div>

      <div className="flex-grow p-4 overflow-auto relative">
        {activeTab === 'editor' && (
          <div className="h-full flex flex-col">
            <textarea
              value={documentContent}
              onChange={(e) => onDocumentChange(e.target.value)}
              placeholder="Live markdown and rich-text editor... Type a prompt and click 'Generate with AI' or 'Generate PDF'!"
              className="w-full h-full p-3 bg-gray-800 text-gray-200 resize-none focus:outline-none font-mono text-sm"
            />
            <div className="absolute bottom-6 right-6 flex items-center space-x-2">
              <button 
                onClick={onGeneratePdf}
                disabled={isLoading}
                className="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md flex items-center transition-all duration-200 disabled:bg-gray-800 disabled:cursor-not-allowed"
              >
                <DocumentIcon className="w-5 h-5 mr-2"/>
                {isLoading ? 'Working...' : 'Generate PDF'}
              </button>
              <button 
                onClick={onGenerateContent} 
                disabled={isLoading}
                className="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md flex items-center transition-all duration-200 disabled:bg-indigo-900 disabled:cursor-not-allowed"
              >
                <AIIcon className="w-5 h-5 mr-2"/>
                {isLoading ? 'Generating...' : 'Generate with AI'}
              </button>
            </div>
          </div>
        )}
        {activeTab === 'pdf' && (
          <div className="h-full flex items-center justify-center flex-col">
            <div className="flex-grow w-full flex items-center justify-center flex-col">
              {selectedPdf ? (
                <div className="text-center p-8 border-2 border-dashed border-gray-600 rounded-lg">
                  <DocumentIcon className="w-16 h-16 mx-auto text-gray-500 mb-4" />
                  <h3 className="text-lg font-semibold text-white">PDF Viewer Area</h3>
                  <p className="text-gray-400 mt-2">Loaded: <span className="font-medium text-indigo-400">{selectedPdf.name}</span></p>
                  <p className="text-xs text-gray-500 mt-1">Size: {(selectedPdf.size / 1024).toFixed(2)} KB</p>
                  <button 
                    onClick={handleUploadClick} 
                    className="mt-4 bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-md text-sm transition-colors duration-200"
                  >
                    Upload a Different PDF
                  </button>
                </div>
              ) : (
                <div className="text-center">
                  <DocumentIcon className="w-16 h-16 mx-auto text-gray-600 mb-4" />
                  <h3 className="text-lg font-semibold text-white">No PDF Uploaded</h3>
                  <p className="text-gray-400 mt-2">Upload a PDF to see the preview and run scripts on it.</p>
                  <button 
                    onClick={handleUploadClick} 
                    className="mt-4 bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-md transition-colors duration-200"
                  >
                    Upload PDF
                  </button>
                </div>
              )}
            </div>
            <input type="file" ref={fileInputRef} onChange={handleFileChange} accept=".pdf" className="hidden" />
            
            {appliedEffects.length > 0 && (
              <div className="w-full mt-4 p-3 bg-gray-900 rounded-lg border border-gray-700 flex-shrink-0">
                <h4 className="text-sm font-semibold text-gray-300 mb-2">Applied Mock Effects</h4>
                <div className="text-xs text-gray-400 space-y-2 max-h-32 overflow-y-auto font-mono">
                  {appliedEffects.map(effect => (
                    <div key={effect.id} className="p-2 bg-gray-800 rounded-md">
                      <strong className="text-indigo-400">{effect.type}:</strong> 
                      <pre className="whitespace-pre-wrap text-gray-300 text-[11px] mt-1">{JSON.stringify(effect, (k,v) => k === 'id' || k === 'type' ? undefined : v, 2)}</pre>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default Workspace;
--- END OF FILE components/Workspace.tsx ---
--- START OF FILE components/Terminal.tsx ---
import React, { useEffect, useRef } from 'react';
import CodeIcon from './icons/CodeIcon';
import AIIcon from './icons/AIIcon';

interface TerminalProps {
  scriptContent: string;
  onScriptChange: (content: string) => void;
  consoleOutput: string[];
  onRun: () => void;
  onDebug: () => void;
  onClear: () => void;
  isLoading: boolean;
}

const Terminal: React.FC<TerminalProps> = ({ scriptContent, onScriptChange, consoleOutput, onRun, onDebug, onClear, isLoading }) => {
  const consoleEndRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    consoleEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [consoleOutput]);

  return (
    <div className="w-full md:w-2/5 flex flex-col bg-gray-900 border-l border-gray-800 flex-shrink-0 overflow-hidden">
      <div className="flex-shrink-0 p-3 bg-gray-900 border-b border-gray-800 flex justify-between items-center">
        <h2 className="text-sm font-semibold text-gray-300 flex items-center"><CodeIcon className="w-5 h-5 mr-2" /> JS Execution Terminal</h2>
        <div className="flex space-x-2">
            <button onClick={onRun} disabled={isLoading} className="bg-green-600 hover:bg-green-700 text-white text-xs font-bold py-1 px-3 rounded-md transition-colors disabled:bg-green-900 disabled:cursor-not-allowed">
                {isLoading ? 'Running...' : 'Run'}
            </button>
            <button onClick={onDebug} disabled={isLoading} className="bg-indigo-600 hover:bg-indigo-700 text-white text-xs font-bold py-1 px-3 rounded-md flex items-center transition-colors disabled:bg-indigo-900 disabled:cursor-not-allowed">
                <AIIcon className="w-4 h-4 mr-1"/>
                {isLoading ? 'Debugging...' : 'Debug'}
            </button>
            <button onClick={onClear} disabled={isLoading} className="bg-gray-600 hover:bg-gray-700 text-white text-xs font-bold py-1 px-3 rounded-md transition-colors disabled:opacity-50">Clear</button>
        </div>
      </div>
      
      {/* Code Editor */}
      <div className="flex-grow flex flex-col h-1/2">
        <textarea
          value={scriptContent}
          onChange={(e) => onScriptChange(e.target.value)}
          placeholder="Write or load a script to execute on the PDF..."
          className="w-full h-full p-3 bg-gray-900 text-green-300 font-mono text-sm resize-none focus:outline-none"
        />
      </div>

      {/* Console Output */}
      <div className="flex-shrink-0 border-t border-gray-800 h-1/2 flex flex-col">
        <h3 className="text-xs font-semibold text-gray-400 bg-gray-900 px-3 py-1 border-b border-gray-800">Console Log</h3>
        <div className="flex-grow p-3 bg-black bg-opacity-20 overflow-y-auto font-mono text-xs">
          {consoleOutput.map((line, index) => (
            <div key={index} className="whitespace-pre-wrap">{line}</div>
          ))}
          <div ref={consoleEndRef} />
        </div>
      </div>
    </div>
  );
};

export default Terminal;
--- END OF FILE components/Terminal.tsx ---
--- START OF FILE components/icons/CodeIcon.tsx ---
import React from 'react';

const CodeIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M17.25 6.75 22.5 12l-5.25 5.25m-10.5 0L1.5 12l5.25-5.25m7.5-3-4.5 16.5" />
  </svg>
);

export default CodeIcon;
--- END OF FILE components/icons/CodeIcon.tsx ---
--- START OF FILE components/icons/DocumentIcon.tsx ---
import React from 'react';

const DocumentIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
  </svg>
);

export default DocumentIcon;
--- END OF FILE components/icons/DocumentIcon.tsx ---
--- START OF FILE components/icons/PaymentIcon.tsx ---
import React from 'react';

const PaymentIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M2.25 8.25h19.5M2.25 9h19.5m-16.5 5.25h6m-6 2.25h3m-3.75 3h15a2.25 2.25 0 0 0 2.25-2.25V6.75A2.25 2.25 0 0 0 19.5 4.5h-15a2.25 2.25 0 0 0-2.25 2.25v10.5A2.25 2.25 0 0 0 4.5 19.5Z" />
  </svg>
);

export default PaymentIcon;
--- END OF FILE components/icons/PaymentIcon.tsx ---
--- START OF FILE components/icons/ScriptIcon.tsx ---
import React from 'react';

const ScriptIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m.75 12 3 3m0 0 3-3m-3 3v-6m-1.5-9H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" />
  </svg>
);

export default ScriptIcon;
--- END OF FILE components/icons/ScriptIcon.tsx ---
--- START OF FILE components/icons/BlockchainIcon.tsx ---
import React from 'react';

const BlockchainIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M13.5 21v-7.5a.75.75 0 0 1 .75-.75h3a.75.75 0 0 1 .75.75V21m-4.5 0H2.25a.75.75 0 0 1-.75-.75v-12a.75.75 0 0 1 .75-.75h12.75a.75.75 0 0 1 .75.75v12a.75.75 0 0 1-.75.75H13.5m-4.5 0h4.5m-4.5-7.5h4.5m5.25-3H4.5m15 0a.75.75 0 0 0 .75-.75V6a.75.75 0 0 0-.75-.75H18a.75.75 0 0 0-.75.75v3.75a.75.75 0 0 0 .75.75Z" />
  </svg>
);

export default BlockchainIcon;
--- END OF FILE components/icons/BlockchainIcon.tsx ---
--- START OF FILE components/icons/AIIcon.tsx ---
import React from 'react';

const AIIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
  <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
    <path strokeLinecap="round" strokeLinejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456Z" />
  </svg>
);

export default AIIcon;
--- END OF FILE components/icons/AIIcon.tsx ---
--- START OF FILE components/icons/ServerIcon.tsx ---
import React from 'react';

const ServerIcon: React.FC<React.SVGProps<SVGSVGElement>> = (props) => (
    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" {...props}>
      <path strokeLinecap="round" strokeLinejoin="round" d="M21.75 17.25v-.228a4.5 4.5 0 0 0-.12-1.03l-2.268-9.64a3.375 3.375 0 0 0-3.285-2.65H8.25a3.375 3.375 0 0 0-3.285 2.65l-2.268 9.64a4.5 4.5 0 0 0-.12 1.03v.228m15.45-1.5H2.55m13.5 0a3 3 0 0 1-3 3m0 0a3 3 0 0 1-3-3m-3.868.015a3 3 0 0 1 3-3h.002a3 3 0 0 1 3 3m3.868 0a3 3 0 0 1-3 3m0 0a3 3 0 0 1-3-3m0-6h.008c.004 0 .008.002.012.005l.348.348a.75.75 0 0 1-.012 1.06l-.348.348a.75.75 0 0 1-1.062 0l-.348-.348a.75.75 0 0 1 0-1.06l.348-.348a.75.75 0 0 1 .708-.216ZM12 12h.008c.004 0 .008.002.012.005l.348.348a.75.75 0 0 1-.012 1.06l-.348.348a.75.75 0 0 1-1.062 0l-.348-.348a.75.75 0 0 1 0-1.06l.348-.348a.75.75 0 0 1 .708-.216Z" />
    </svg>
);

export default ServerIcon;
--- END OF FILE components/icons/ServerIcon.tsx ---
--- START OF FILE mocks/MockAI.ts ---
// mocks/MockAI.ts
// A deterministic, rule-based "AI" interpreter. Replaceable by an on-device LLM later.

export type Effect =
  | { op: 'log'; message: string }
  | { op: 'addWatermark'; page: number; text: string }
  | { op: 'highlightText'; text: string }
  | { op: 'lockPages'; pages: number[]; priceCents?: number }
  | { op: 'mintNFT'; metadata: Record<string, any> }
  | { op: 'runPayment'; priceCents: number; reason?: string };

export type AIResponse = {
  success: boolean;
  effects: Effect[];
  explanation?: string;
};

export class MockAI {
  // Interpret script text and return a plan of effects.
  static interpretScript(scriptText: string): AIResponse {
    // Heuristics: look for keywords to create meaningful effects.
    const effects: Effect[] = [];
    const s = scriptText.toLowerCase();

    if (s.includes('watermark')) {
      const match = s.match(/watermark(?:.*page\s+(\d+))?(?:.*text\s*["'](.*?)["'])?/i);
      const page = match && match[1] ? Number(match[1]) : 1;
      const text = match && match[2] ? match[2] : 'CONFIDENTIAL';
      effects.push({ op: 'addWatermark', page, text });
      effects.push({ op: 'log', message: `Planned watermark on page ${page} with text: "${text}"`});
    }

    if (s.includes('pay') || s.includes('unlock')) {
      const priceMatch = s.match(/\$?(\d+(\.\d+)?)/);
      const priceCents = priceMatch ? Math.round(Number(priceMatch[1]) * 100) : 500;
      effects.push({ op: 'lockPages', pages: [2,3], priceCents });
      effects.push({ op: 'log', message: `Will lock pages [2,3] for ${priceCents} cents.`});
    }

    if (s.includes('mint nft') || s.includes('mint')) {
      effects.push({ op: 'mintNFT', metadata: { title: 'Document Edition', timestamp: Date.now() }});
      effects.push({ op: 'log', message: 'Will mint NFT for current doc version.' });
    }

    if (effects.length === 0) {
      // fallback: echo-as-log and attempt to "highlight" text terms
      const tokens = scriptText.match(/\w+/g) || [];
      const maybeWord = tokens.length > 0 ? tokens[Math.floor(tokens.length/2)] : 'example';
      effects.push({ op: 'log', message: 'No direct heuristic match — defaulting to highlight.' });
      effects.push({ op: 'highlightText', text: maybeWord });
    }

    return { success: true, effects, explanation: 'Interpreted by MockAI heuristics.' };
  }

  // Debugging assistant: "fix" code by returning recommended change (mock)
  static debugScript(scriptText: string, errorMessage?: string) {
    const suggestion = scriptText + `\n\n// AI Suggestion: The error "${errorMessage}" might be due to an unhandled null value. Consider adding checks before accessing properties. (Mocked Response)`;
    return { suggestion, explanation: `MockAI suggests adding safe wrappers and validating inputs for the error: ${errorMessage}` };
  }
}
--- END OF FILE mocks/MockAI.ts ---
--- START OF FILE mocks/MockChain.ts ---
// mocks/MockChain.ts
export type ChainEvent = {
  id: string;
  type: string;
  payload: any;
  timestamp: number;
};

const KEY = 'pdfx_mock_chain';

function read(): ChainEvent[] {
  try { return JSON.parse(localStorage.getItem(KEY) || '[]'); } catch(e) { return []; }
}
function write(arr: ChainEvent[]) { localStorage.setItem(KEY, JSON.stringify(arr)); }

export const MockChain = {
  push(type: string, payload: any) {
    const arr = read();
    const ev: ChainEvent = { id: 'ev_' + Date.now() + '_' + Math.floor(Math.random()*10000), type, payload, timestamp: Date.now() };
    arr.push(ev);
    write(arr);
    return ev;
  },
  list() { return read().sort((a, b) => b.timestamp - a.timestamp); },
  clear() { write([]); }
};
--- END OF FILE mocks/MockChain.ts ---
--- START OF FILE mocks/MockPayment.ts ---
// mocks/MockPayment.ts
export type PaymentSession = {
  id: string;
  amountCents: number;
  currency: string;
  status: 'pending'|'paid'|'failed';
  createdAt: number;
  metadata?: Record<string, any>;
};

const STORE_KEY = 'pdfx_mock_payments';

function readAll(): PaymentSession[] {
  try {
    const raw = localStorage.getItem(STORE_KEY);
    return raw ? JSON.parse(raw) : [];
  } catch (e) { return []; }
}
function writeAll(sessions: PaymentSession[]) {
  localStorage.setItem(STORE_KEY, JSON.stringify(sessions));
}

export const MockPayment = {
  createSession(amountCents: number, currency = 'usd', metadata?: Record<string, any>): PaymentSession {
    const s: PaymentSession = {
      id: 'mockpay_' + Date.now() + '_' + Math.floor(Math.random()*10000),
      amountCents,
      currency,
      status: 'pending',
      createdAt: Date.now(),
      metadata
    };
    const all = readAll();
    all.push(s);
    writeAll(all);
    return s;
  },
  confirmSession(sessionId: string): PaymentSession | null {
    const all = readAll();
    const s = all.find(x => x.id === sessionId);
    if (!s) return null;
    s.status = 'paid';
    writeAll(all);
    return s;
  },
  list(): PaymentSession[] { return readAll().sort((a,b) => b.createdAt - a.createdAt); },
  clear() { writeAll([]); }
};
--- END OF FILE mocks/MockPayment.ts ---
--- START OF FILE mocks/SandboxRunner.ts ---
// mocks/SandboxRunner.ts
// Accepts script text -> asks MockAI for an effect plan -> executes effects by calling handler callbacks.

import { MockAI, Effect } from './MockAI';
import { MockPayment } from './MockPayment';
import { MockChain } from './MockChain';

export type EffectHandlers = {
  onLog?: (msg: string) => void;
  onWatermark?: (page: number, text: string) => void;
  onHighlight?: (text: string) => void;
  onLockPages?: (pages: number[], priceCents?: number) => void;
  onMintNFT?: (metadata: any) => void;
};

export async function runScriptInMockSandbox(scriptText: string, handlers: EffectHandlers) {
  // 1) interpret via AI
  const aiResp = MockAI.interpretScript(scriptText);
  handlers.onLog?.(`[MockAI] ${aiResp.explanation}`);

  for (const e of aiResp.effects) {
    // Add a small delay to simulate processing
    await new Promise(resolve => setTimeout(resolve, 150));
    switch (e.op) {
      case 'log':
        handlers.onLog?.(e.message);
        MockChain.push('log', { message: e.message });
        break;
      case 'addWatermark':
        handlers.onWatermark?.(e.page, e.text);
        MockChain.push('watermark', { page: e.page, text: e.text });
        break;
      case 'highlightText':
        handlers.onHighlight?.(e.text);
        MockChain.push('highlight', { text: e.text });
        break;
      case 'lockPages':
        handlers.onLockPages?.(e.pages, e.priceCents);
        // create a mock payment session for the lock
        const session = MockPayment.createSession(e.priceCents ?? 500, 'usd', { reason: 'lockPages', pages: e.pages });
        MockChain.push('payment_session_created', session);
        handlers.onLog?.(`Created mock payment session ${session.id} for unlocking pages.`);
        break;
      case 'mintNFT':
        handlers.onMintNFT?.(e.metadata);
        MockChain.push('mint', e.metadata);
        break;
      case 'runPayment':
        const s = MockPayment.createSession(e.priceCents, 'usd', { reason: e.reason });
        MockChain.push('payment_session_created', s);
        handlers.onLog?.(`Mock payment created ${s.id}`);
        break;
      default:
        handlers.onLog?.(`Unknown effect: ${(e as any).op}`);
    }
  }
  return aiResp;
}
--- END OF FILE mocks/SandboxRunner.ts ---